Входные данные:
предусмотреть выбор алгоритма ZF или MMSE
N =1000; % число отсчетов,большое большое число до 10^6
Eb_N0_dB =(0:15); отношение сигнал/шум (ОСШ) диапазон целых чисел, может задавать пользователь не более 30
nTx = 2; число передающих антенн, целое чило
nRx = 2; число принимающих антенн, целое чило
L=3; %Длина ИХ, целое число, не более 7


1. Канальная матрица

zz=1000;% длинна посылки, колличество элементов в строке (не обязательно делать)
nz=N/zz;(не обязательно делать)

%векторы импульсной характеристики, массив рандомных чисел от -1 до 1 размерностью от 1 до L
ht11 = [0.9 -0.5 0.3 ]; 
ht12 = [0.3 -0.6 -0.4];
ht21 = [0.2 0.7 -0.1 ];
ht22 = [-0.1 0.8 0.1];
...
htnTxnRx=[1...L]; %колличество ИХ соответствует числу nTx и nRx;

%канальная матрица в каждый отчсет ИХ, где учитываются отсчеты от предающих антенн nTx до приемных антенн nRx  
hM1 =[ht11(1),ht21(1),...htnTx1(1);ht12(1),ht22(1),...htnTx2(1);...;htnTx2(1),htnTx2(1),...htnTxnRx(1)]; 
hM2 =[ht11(2),ht21(2),...htnTx1(2);ht12(2),ht22(2),...htnTx2(2);...;htnTx2(2),htnTx2(2),...htnTxnRx(2)];
hM3 =[ht11(3),ht21(3),...htnTx1(3);ht12(3),ht22(3),...htnTx2(3);...;htnTx2(3),htnTx2(3),...htnTxnRx(3)];
...
hML=[ht11(L),ht21(L),...htnTx1(L);ht12(L),ht22(L),...htnTx2(L);...;htnTx2(L),htnTx2(L),...htnTxnRx(L)];

%длина интервала обработки принимаемых сигналов, 2 соответствует 2 антеннам 
         dl=(zz/2)+L-1;
        
%пустая канальная матрица, 2 из-за 2 антенн
        HM=zeros(2*dl,zz);
        
            for k=0:2:(zz-2)

				HM((1+k:2+k),(1+k:2+k))=hM1;
				HM((3+k:4+k),(1+k:2+k))=hM2;
				HM((5+k:6+k),(1+k:2+k))=hM3;

            end

2.Передатчик

% пустый вектора принятого сигнала для 2 алгоритмов
nErrZF=zeros(1,length(Eb_N0_dB));
nErrmmse=zeros(1,length(Eb_N0_dB));


    for ii = 1:length(Eb_N0_dB)

	ip = rand(1,N)>0.5; % генерация случайных чисел 0 и 1 с равной вероятностью, т. е. ip = 0     0     1...     
    	s = 2*ip-1; % BPSK модуляция 0 -> -1; 1 -> 1  =  -1    -1    1...

	%делим сигнал на посылки по zz
	
	ss=GetMatrix(s,zz); %функция,которая делит вектор-сигнала на колл-во-colCount длинну фильтра(3), из вектора получаем матрицу

	ssipZF=zeros(nz,zz);% пустая матрица
	ssipmmse=zeros(nz,zz);% пустая матрица

3. MIMO-канал связи
	
        for ff=1:(nz)

		st=ss(ff,:);
%MIMO 2x2 (nTx х nRx)

%делитель потока сигнала делится по колличеству nTx, далее будет рассмотрено для случая 2х2 , сколько nTx столько s,chanOut,n, y
		ind1=1:2:length(st);
		ind2=2:2:length(st);
		s1=st(ind1);
		s2=st(ind2);

%сигнал прошедший через канал
		chanOut1 = conv(s1,ht11)+conv(s2,ht21);% conv - свертка одномерных массивов
		chanOut2 = conv(s1,ht12)+conv(s2,ht22);
        
% генеация отсчетов Гауссовского шума
        n1 = 1/sqrt(2)*(randn(1,zz/2+L-1) + 1i*randn(1,zz/2+L-1));
        n2=1/sqrt(2)*(randn(1,zz/2+L-1) + 1i*randn(1,zz/2+L-1));

%сигнал на входе эквалайзера, прошедший весь канал связи с БГШ
		y1 = chanOut1  + 10^(-Eb_N0_dB(ii)/20)*n1;
		y2 = chanOut2  + 10^(-Eb_N0_dB(ii)/20)*n2;

4.Эквалайзер

            
        HMzf=HM;% пустая матрица для zf алгоритма 
        HMmmse=HM;% пустые матрицы для mmse алгоритма 
 
%эквалайзер для zf алгоритма        
        WZF=(HMzf'*HMzf)\HMzf';

%эквалайзер для mmse алгоритма
        Wmmse=(HMmmse'*HMmmse+(10^(-Eb_N0_dB(ii)/10)*(eye(zz))))\HMmmse';
 
5.Фильтрация       
        yHat=GetVector(y1,y2);% объединитель потока
 
        ySampZF = WZF*yHat'; % результат работы ZF алгоритма, сигнал после "очистки " эквалайзером
        ySampmmse = Wmmse*yHat'; % результат работы MMSE алгоритма, сигнал после "очистки " эквалайзером
        
%Декодирование
     	ipHatZFst = real(ySampZF')>0;
        ipHatmmsest = real(ySampmmse')>0;

%объединение посылок        
        ssipZF(ff,:)=ipHatZFst;
        ssipmmse(ff,:)=ipHatmmsest;
        end

6. Подсчет Ошибки
     
    	ipHatZF=reshape(ssipZF', 1, N); % Функция B = reshape(A, m, n) возвращает массив размером m х n, сформированный из элементов массива A путем их последовательной выборки по столбцам. Если число элементов массива A не равно произведению m * n, выводится сообщение об ошибке.
	ipHatmmse=reshape(ssipmmse', 1, N);
    
% Подсчет абсолютной Ошибки
    	nErrZF(ii) = size(find((ip- ipHatZF)),2);
	nErrmmse(ii) = size(find((ip- ipHatmmse)),2);

    end


% Подсчет побитовой Ошибки    
simBerZF = nErrZF/N; 
simBermmse = nErrmmse/N;


7. Построение графиков
close all
figure
semilogy(Eb_N0_dB,simBerZF(1,:),'bp-','LineWidth',2);
hold on
semilogy(Eb_N0_dB,simBermmse(1,:),'rd-','LineWidth',2);

axis([0 15 10^-5 1.5])
grid on
legend('ZF эквалайзер', 'MMSE эквалайзер');
xlabel('ОСШ,dB');
ylabel('Битовый коэффициент ошибок');
title('BER системы MIMO 2х2 с BPSK модуляции, в канале с межсимвольной интерференцией');